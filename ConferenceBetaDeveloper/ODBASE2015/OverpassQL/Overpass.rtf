{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww15180\viewh14020\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs28 \cf0 The O
\fs32 verpass API (or OSM3S) is a read-only API that allows us to query OSM map data. Overpass API is optimized for data consumers that need to select OSM data by search criteria like location, types of objects, tag values, proximity or combinations of them.\
\
Overpass API has the query languages Overpass XML and Overpass QL. Both languages are equivalent and have a high power of expressivity. They allow us to handle with OSM objects ((a) standalone queries) and set of OSM objects ((b) composition and filtering queries). With respect to (a), the query languages allow us to express queries in order to search a particular object and recursion forward or backward membership links from an object (for instance, it returns the node members of all ways from a OSM object). With respect to (b), the query languages can express queries over a very rich set of search criteria over set of OSM objects. Among others, we can express to find all data in a bounding box (positioning), to find all data near something else (i.e. proximity), to find all data by tag value (exact value, non-exact value, regular expressions), negation, union, difference, intersection, filtering with a very rich set of selectors, by polygon, by area pivot, and so on. Therefore, and we can check, query languages with a high power of expressivity.\
\
Now and with respect to our library, let us remark the following. We implement the semantic of Clementini\'92s operators (i.e. contains, equals, crosses, disjoint and touches) in our library, providing a repertory of urban operators that can be combined with Higher Order facilities of XQuery. It is true that the combination of higher order facilities is also present in Overpass API. However, this facilities (i.e. composition and filtering queries) in Overpass API cannot be combined with spatial operators such as Clementini\'92s ones. In Overpass API, we can handle spatial locations and proximity by means of bounding box and around selector but a composition or filtering query distinguishing between a spatial crossing or touching among ways cannot be expressed. In Overpass API, only one type of spatial intersection is considered (proximity 0 by using across selector). For instance, the query (allowed in our library) \'93retrieve the streets crossing the way Calzada de Castro and ending to the way Avenida de Montserrat\'94 is not allowed in Overpass API. In our library, this query is implemented by \
using the high order function filter and our urban operators isCrossing and isEndingTo (i.e. the Clementini\'92s operators crosses and touches, respectively). Therefore, in order to express queries over OSM map data, our main contribution w.r.t. Overpass API is to handle composition and filtering facilities in combination of spatial operators implemented from the semantic of the Clementini\'92s operators.\
\
On the other hand, Overpass API has a very high power of expressivity for keyword search based queries. Now, our main goal is to focused on the main features of Overpass API for keyword queries in order to improve the power of expressivity of our library implementing them and allowing the most important keyword search criteria in our queries (i.e. key regex, value regex, recursion memberships links, \'85)\
}